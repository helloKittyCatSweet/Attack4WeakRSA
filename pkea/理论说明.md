# 广义 RSA 部分私钥泄露攻击 - 理论详解

## 一、问题定义与背景

### 1.1 广义 RSA 密码系统

**定义**：广义 RSA 使用模数
```
N = p^r · q^s
```
其中：
- p, q 为不同的大素数
- r, s ≥ 1 为整数幂次
- 当 r = s = 1 时退化为标准 RSA

**欧拉函数**：
```
φ(N) = φ(p^r) · φ(q^s)
     = p^(r-1)·(p-1) · q^(s-1)·(q-1)
```

**密钥生成**：
1. 选择公钥指数 e，满足 gcd(e, φ(N)) = 1
2. 计算私钥 d ≡ e^(-1) (mod φ(N))
3. 公钥：(N, e)
4. 私钥：d（或等价地 (p, q, r, s)）

**加解密**：
- 加密：c ≡ m^e (mod N)
- 解密：m ≡ c^d (mod N)

---

### 1.2 部分私钥泄露模型

**攻击场景**：攻击者通过侧信道攻击（如时序攻击、功耗分析、冷启动攻击等）获得私钥 d 的部分比特信息。

**泄露类型**：

#### (1) MSB 泄露（Most Significant Bits）
已知 d 的最高 δ·log₂(d) 位。

设 d 的二进制表示为：
```
d = d_(n-1) d_(n-2) ... d_1 d_0
```
已知：d_(n-1), d_(n-2), ..., d_(n-k)

可表示为：
```
d = d₀ + x
```
其中：
- d₀ = ⌊d / 2^(n-k)⌋ · 2^(n-k)（已知部分）
- x = d mod 2^(n-k)（未知部分）
- |x| < X = 2^(n-k)

#### (2) LSB 泄露（Least Significant Bits）
已知 d 的最低 δ·log₂(d) 位。

```
d = d₀ + x
```
其中：
- d₀ = d mod 2^k（已知部分）
- x = d - d₀（未知部分）
- |x| < X = 2^(n-k+1)

**泄露比例**：
```
δ = (已知位数) / (总位数)
```

---

## 二、数学基础

### 2.1 模方程的小根问题

**问题**：给定模方程
```
f(x) ≡ 0 (mod M)
```
求满足 |x| < X 的整数解 x，其中 X ≪ M。

**经典方法**：
- 暴力搜索：O(X)，当 X 很大时不可行
- Coppersmith 方法：多项式时间（在某些条件下）

---

### 2.2 Coppersmith 定理

**单变量情况**（Howgrave-Graham 1997）：

**定理**：设 f(x) 为首一多项式，度为 δ，模为 M。若存在整数 x₀ 满足：
1. f(x₀) ≡ 0 (mod M)
2. |x₀| < X

且 X 满足：
```
X < M^(1/δ) / 2
```

则可在多项式时间内找到 x₀。

**核心思想**：
1. 构造一组多项式 {g_i(x)}，它们在模 M 下与 f(x) 相关
2. 将多项式系数作为向量构成格 L
3. 使用 LLL 算法找到格中的短向量
4. 短向量对应的多项式 G(x) 在**整数域**上有根 x₀
5. 求解 G(x) = 0 得到 x₀

---

### 2.3 格（Lattice）理论

**定义**：格 L 是 ℝⁿ 中的离散加法子群，由基向量 {b₁, b₂, ..., b_m} 张成：
```
L = {∑ a_i·b_i : a_i ∈ ℤ}
```

**格基矩阵**：
```
B = [b₁]
    [b₂]
    [...]
    [b_m]
```

**行列式**：
```
det(L) = |det(B)|
```

**最短向量问题（SVP）**：找到格中非零的最短向量。

**LLL 算法**（Lenstra-Lenstra-Lovász 1982）：
- 在多项式时间内找到"足够短"的向量
- 保证：||v|| ≤ 2^(n/2) · det(L)^(1/n)

---

### 2.4 Howgrave-Graham 引理

**引理**：设 G(x) 为整系数多项式，度为 δ。若：
1. G(x₀) ≡ 0 (mod M^m)（对某个整数 x₀）
2. ||G(xX)|| < M^m / √n（欧几里得范数）

则 G(x₀) = 0 在整数域上成立。

**证明思路**：
```
|G(x₀)| = |∑ G_i · x₀^i|
        ≤ ∑ |G_i| · |x₀|^i
        ≤ ∑ |G_i| · X^i
        = ||G(xX)||₁
        ≤ √n · ||G(xX)||₂
        < M^m
```
因此 G(x₀) 是 M^m 的倍数且 |G(x₀)| < M^m，故 G(x₀) = 0。

---

## 三、攻击方法

### 3.1 基本思路

**已知信息**：
- 公钥 (N, e)
- 私钥部分信息 d₀（泄露比例 δ）

**目标**：恢复完整私钥 d = d₀ + x

**关键方程**：
```
e·d ≡ 1 (mod φ(N))
```
代入 d = d₀ + x：
```
e·(d₀ + x) ≡ 1 (mod φ(N))
e·x ≡ 1 - e·d₀ (mod φ(N))
```

定义：
```
f(x) = e·x + (e·d₀ - 1)
```
则：
```
f(x) ≡ 0 (mod φ(N))
```

**问题转化**：求 f(x) ≡ 0 (mod M) 的小根，其中 M = φ(N) 或其因子。

---

### 3.2 格构造（单变量）

**参数**：
- m：格构造参数（控制格维度）
- t：额外多项式数量

**多项式集合**：

**(1) 主多项式族**：
```
g_{i,j}(x) = x^i · f(x)^j · M^(m-j)
```
其中：
- j = 0, 1, ..., m-1
- i = 0, 1, ..., m-j-1

**(2) 辅助多项式族**：
```
h_i(x) = x^i · f(x)^m
```
其中：
- i = 0, 1, ..., t-1

**总数**：
```
n = ∑_{j=0}^{m-1} (m-j) + t
  = m(m+1)/2 + t
```

---

### 3.3 格基矩阵

**系数向量**：对每个多项式 g(x) = ∑ g_i·x^i，构造向量：
```
v = (g_0·X^0, g_1·X^1, g_2·X^2, ..., g_d·X^d)
```
其中 X 是 x 的上界。

**格基矩阵 L**：
```
L = [v₁]
    [v₂]
    [...]
    [v_n]
```

**示例**（m=2, t=1, f(x) = e·x + C）：

多项式：
1. g_{0,0} = M²
2. g_{0,1} = f(x)·M = (e·x + C)·M
3. g_{1,1} = x·f(x)·M = (e·x² + C·x)·M
4. g_{0,2} = f(x)² = e²·x² + 2eC·x + C²
5. h_0 = f(x)² = e²·x² + 2eC·x + C²

矩阵（缩放后）：
```
L = [M²,      0,        0      ]
    [C·M·X,   e·M·X,    0      ]
    [0,       C·M·X²,   e·M·X² ]
    [C²·X⁰,   2eC·X¹,   e²·X²  ]
    [C²·X⁰,   2eC·X¹,   e²·X²  ]
```

---

### 3.4 LLL 约简与根恢复

**步骤**：

1. **LLL 约简**：
   ```
   L' = LLL(L)
   ```
   得到约简后的格基。

2. **提取短向量**：
   取 L' 的第一行（或前几行）：
   ```
   v = (v₀, v₁, v₂, ..., v_d)
   ```

3. **重构多项式**：
   ```
   G(x) = ∑ (v_i / X^i) · x^i
   ```

4. **求整数根**：
   - 单变量：使用整数因式分解或根查找算法
   - 多变量：使用 Gröbner 基或结式消元

5. **验证**：
   检查 f(x) ≡ 0 (mod M) 是否成立。

---

### 3.5 成功条件

**理论界限**（Boneh-Durfee 类型）：

对于标准 RSA (r=s=1)，MSB 泄露攻击成功的充分条件：
```
δ > 1 - 1/√2 ≈ 0.293
```

对于广义 RSA (N = p^r·q^s)，界限依赖于 (r, s)：
```
δ > δ_critical(r, s, α, β)
```
其中：
- α = log_N(e)（公钥指数的相对大小）
- β = log_N(d)（私钥的相对大小）

**实践中**：
- 需要 δ ≥ 0.4-0.6 才能在合理时间内成功
- 格维度 n 越大，成功率越高但计算代价指数增长
- LLL 可能不足，需要 BKZ（Block Korkine-Zolotarev）

---

## 四、复杂度分析

### 4.1 时间复杂度

**LLL 算法**：
```
O(n⁴ · log²(max|b_ij|))
```
其中 n 为格维度。

**格维度**：
```
n = m(m+1)/2 + t ≈ O(m²)
```

**总复杂度**：
```
O(m⁸ · poly(log N))
```

**实际运行时间**（经验值）：
| 格维度 n | LLL 时间 | BKZ-20 时间 |
|----------|----------|-------------|
| 10       | < 0.1s   | < 1s        |
| 20       | < 1s     | < 10s       |
| 50       | < 10s    | < 5min      |
| 100      | < 1min   | > 1h        |

---

### 4.2 空间复杂度

**格基矩阵**：
```
O(n² · log N) bits
```

**示例**（N 为 1024 位，n=50）：
```
50² × 1024 bits ≈ 2.5 MB
```

---

## 五、两种方案对比

论文提出两种方案，对应不同的模选择：

### 方案 1：模 φ(N)

**模方程**：
```
e·d ≡ 1 (mod φ(N))
```

**优点**：
- 理论分析简洁
- 适用于标准密钥生成

**缺点**：
- φ(N) 未知（需要分解 N）
- 实际攻击中需要近似

### 方案 2：模 (p-1)(q-1)

**模方程**：
```
e·d ≡ 1 (mod (p-1)(q-1))
```

**优点**：
- 模更小，格约简更快
- 某些情况下成功率更高

**缺点**：
- 需要额外假设或信息

---

## 六、防御措施

### 6.1 密钥保护

1. **硬件安全模块（HSM）**：私钥不离开安全硬件
2. **可信平台模块（TPM）**：密钥绑定到硬件
3. **密钥分割**：多方计算，无单点泄露

### 6.2 侧信道防护

1. **常量时间实现**：避免时序泄露
2. **掩码技术**：随机化中间值
3. **噪声注入**：干扰功耗分析

### 6.3 参数选择

1. **增加密钥长度**：使用 ≥ 2048 位 RSA
2. **避免广义 RSA**：除非必要，使用标准 RSA
3. **定期更换密钥**：限制泄露窗口

---

## 七、参考文献

1. **Coppersmith, D.** (1996). "Small Solutions to Polynomial Equations, and Low Exponent RSA Vulnerabilities." *Journal of Cryptology*, 10(4), 233-260.

2. **Howgrave-Graham, N.** (1997). "Finding Small Roots of Univariate Modular Equations Revisited." *Cryptography and Coding*, LNCS 1355, 131-142.

3. **Boneh, D., & Durfee, G.** (2000). "Cryptanalysis of RSA with Private Key d Less than N^0.292." *IEEE Transactions on Information Theory*, 46(4), 1339-1349.

4. **Lenstra, A.K., Lenstra, H.W., & Lovász, L.** (1982). "Factoring Polynomials with Rational Coefficients." *Mathematische Annalen*, 261(4), 515-534.

5. **主要论文**：*Partial Key Exposure Attacks on RSA with Moduli N=p^r q^s*

---

## 八、附录：关键公式汇总

### A. 欧拉函数
```
φ(p^r · q^s) = p^(r-1)·(p-1) · q^(s-1)·(q-1)
```

### B. 密钥关系
```
e·d ≡ 1 (mod φ(N))
d ≡ e^(-1) (mod φ(N))
```

### C. 基本多项式
```
f(x) = e·x + (e·d₀ - 1)
f(x) ≡ 0 (mod M)
```

### D. 格多项式
```
g_{i,j}(x) = x^i · f(x)^j · M^(m-j)
h_i(x) = x^i · f(x)^m
```

### E. Howgrave-Graham 条件
```
||G(xX)||₂ < M^m / √n  ⟹  G(x₀) = 0 (整数域)
```

### F. 成功界限（近似）
```
δ > 1 - √((r+s)/(r·s)) · (1-α)
```
其中 α = log_N(e)。

